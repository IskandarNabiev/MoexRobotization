matrix = [[20, 4, 0, 2, 4],
          [6,  3,  9, 1, 2],
          [1,  0, -1, 1, 10],
          [8,  11, 0, 2, 5],
          [9,  1, -1, 2, 18]]


# Строка, столбец, главная и побочная диагонали могут быть сразу обнаружены,
# если взглянуть на комбинацию x и y.

# Column = x     Row = y        F-Diag = x+y   B-Diag = x-y     B-Diag` = x-y-MIN
#   | 0  1  2      | 0  1  2      | 0  1  2      | 0  1  2        | 0  1  2
# --|---------   --|---------   --|---------   --|---------     --|---------
# 0 | 0  1  2    0 | 0  0  0    0 | 0  1  2    0 | 0  1  2      0 | 2  3  4
# 1 | 0  1  2    1 | 1  1  1    1 | 1  2  3    1 |-1  0  1      1 | 1  2  3
# 2 | 0  1  2    2 | 2  2  2    2 | 2  3  4    2 |-2 -1  0      2 | 0  1  2

# Из диаграммы видно, что каждая диагональ и ось однозначно идентифицируются с помощью этих уравнений.
# Возьмем каждый уникальный номер из каждой таблицы и создаем контейнер для этого идентификатора.

# Побочные диагонали смещены так, чтобы начинаться с нулевого индекса, и
# длина главных диагоналей всегда равна длине побочных диагоналей.

max_col = len(matrix[0])
max_row = len(matrix)

cols = [[] for _ in range(max_col)]
rows = [[] for _ in range(max_row)]
fdiag = [[] for _ in range(max_row + max_col - 1)]
bdiag = [[] for _ in range(len(fdiag))]
min_bdiag = -max_row + 1

for x in range(max_col):
    for y in range(max_row):
        cols[x].append(matrix[y][x])
        rows[y].append(matrix[y][x])
        fdiag[x+y].append(matrix[y][x])
        bdiag[x-y-min_bdiag].append(matrix[y][x])

# Выводим все последовательности обратного диагоналя
print(fdiag)

# Минимальная сумма диагоналя
min_sum = min(map(sum, fdiag))
# Элементы минимальной суммы диагоналя
print(max(filter(lambda x:sum(x) == min_sum, fdiag), key=len))